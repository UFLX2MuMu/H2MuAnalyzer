// Class: ReadBDTG_AWB_lite
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTG_AWB_lite
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/09       [395785]
Creator        : xzuo
Date           : Mon May 13 00:33:15 2019
Host           : Linux cmsbuild49.cern.ch 2.6.32-696.10.2.el6.x86_64 #1 SMP Thu Sep 14 16:35:02 CEST 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/work/x/xzuo/h2mm_944/src/H2MuAnalyzer/TrainMVA
Training events: 34564
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "40" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "0.000001" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "10" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 16
dimu_mass                     dimu_mass                     dimu_mass                     M(#mu#mu)                     GeV                               'F'    [105.000305176,159.994644165]
dimu_pt                       dimu_pt                       dimu_pt                       p_{T}(#mu#mu)                 GeV                               'F'    [0.386133939028,1336.1328125]
lep_pt                        lep_pt                        lep_pt                        p_{T}(lep)                    GeV                               'F'    [10.0008382797,606.851867676]
ldimu_abs_dEta                ldimu_abs_dEta                ldimu_abs_dEta                |d#eta(lH)|                                                     'F'    [7.44881326682e-05,7.8463716507]
ldimu_dR                      ldimu_dR                      ldimu_dR                      dR(lH)                                                          'F'    [0.00688903685659,7.85429000854]
cts_lmuSS                     cts_lmuSS                     cts_lmuSS                     cos(#theta*)(l#muSS)                                            'F'    [-0.999946057796,0.998620390892]
cts_lmuOS                     cts_lmuOS                     cts_lmuOS                     cos(#theta*)(l#muOS)                                            'F'    [-0.999962508678,0.999976456165]
lmuSS_abs_dEta                lmuSS_abs_dEta                lmuSS_abs_dEta                |d#eta(l#muSS)|                                                 'F'    [3.44216823578e-05,4.68873596191]
lmuSS_dR                      lmuSS_dR                      lmuSS_dR                      dR(l#muSS)                                                      'F'    [0.000892890559044,5.62872123718]
lmuOS_abs_dEta                lmuOS_abs_dEta                lmuOS_abs_dEta                |d#eta(l#muOS)|                                                 'F'    [5.88297843933e-05,4.79955911636]
lmuOS_dR                      lmuOS_dR                      lmuOS_dR                      dR(l#muOS)                                                      'F'    [0.00125709886197,5.31066989899]
met_pt                        met_pt                        met_pt                        p_{T}(met)                    GeV                               'F'    [0.376445323229,1240.00231934]
mt_lmet                       mt_lmet                       mt_lmet                       MT(lmet)                      GeV                               'F'    [0.000780088535976,686.686645508]
abs_dPhi_lmet                 abs_dPhi_lmet                 abs_dPhi_lmet                 d#phi(lmet)                                                     'F'    [2.01463699341e-05,3.14144277573]
mht_pt                        mht_pt                        mht_pt                        p_{T}(mht)                    GeV                               'F'    [0.387862235308,1172.1184082]
mt_lmht                       mt_lmht                       mt_lmht                       MT(lmht)                      GeV                               'F'    [0.000837853760459,852.23425293]
NSpec 7
event_wgt                     event_wgt                     event_wgt                     event weight                                                    'F'    [-1.52547264099,3.95628476143]
xsec_norm                     xsec_norm                     xsec_norm                     xsec normal                                                     'F'    [1.59999999596e-05,0.298918008804]
Sample_ID                     Sample_ID                     Sample_ID                     Sample ID                                                       'F'    [-242424,24981]
mu1_lepMVA                    mu1_lepMVA                    mu1_lepMVA                    lepMVA(#mu1)                                                    'F'    [0.403881728649,0.999852478504]
mu2_lepMVA                    mu2_lepMVA                    mu2_lepMVA                    lepMVA(#mu2)                                                    'F'    [0.400503069162,0.999816179276]
lep_lepMVA                    lep_lepMVA                    lep_lepMVA                    lepMVA(lep)                                                     'F'    [0.400008410215,0.99943780899]
dimu_mass                     dimu_mass                     dimu_mass                     mass(#mu#mu)                  GeV                               'F'    [105.000305176,159.994644165]


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTG_AWB_liteNode
   
#ifndef BDTG_AWB_liteNode__def
#define BDTG_AWB_liteNode__def
   
class BDTG_AWB_liteNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTG_AWB_liteNode ( BDTG_AWB_liteNode* left,BDTG_AWB_liteNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTG_AWB_liteNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTG_AWB_liteNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTG_AWB_liteNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTG_AWB_liteNode*   fLeft;     // pointer to the left daughter node
   BDTG_AWB_liteNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTG_AWB_liteNode::~BDTG_AWB_liteNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTG_AWB_liteNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTG_AWB_liteNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTG_AWB_lite : public IClassifierReader {

 public:

   // constructor
   ReadBDTG_AWB_lite( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTG_AWB_lite" ),
        fNvars( 16 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "dimu_mass", "dimu_pt", "lep_pt", "ldimu_abs_dEta", "ldimu_dR", "cts_lmuSS", "cts_lmuOS", "lmuSS_abs_dEta", "lmuSS_dR", "lmuOS_abs_dEta", "lmuOS_dR", "met_pt", "mt_lmet", "abs_dPhi_lmet", "mht_pt", "mt_lmht" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTG_AWB_lite() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[16];
   double fVmax[16];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[16];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTG_AWB_liteNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTG_AWB_lite::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTG_AWB_liteNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTG_AWB_liteNode*)current->GetRight();
         else current=(BDTG_AWB_liteNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDTG_AWB_lite::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00896436) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00771428) , 
0, 110.95, 1, 0, 0.0623323,-0.437668) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00463145) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00222725) , 
1, 131.149, 1, 0, 0.316101,-0.183899) , 
0, 115.908, 1, 0, 0.119467,-0.380533) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0243459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00190475) , 
0, 128.919, 1, 0, 0.839532,0.339532) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0087201) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00852421) , 
0, 133.553, 1, 0, 0.0445632,-0.455437) , 
0, 130.907, 1, 0, 0.682913,0.182913) , 
0, 119.999, 1, 0, 0.5,-1.35436e-15)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00887775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00764025) , 
0, 110.95, 1, 0, 0.0623323,-0.433417) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00458558) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00218844) , 
1, 131.149, 1, 0, 0.316101,-0.182154) , 
0, 115.908, 1, 0, 0.119467,-0.376846) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0235411) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00187989) , 
0, 128.919, 1, 0, 0.839532,0.328037) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0085925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00844968) , 
0, 133.553, 1, 0, 0.0445632,-0.45116) , 
0, 130.907, 1, 0, 0.682913,0.174525) , 
0, 119.999, 1, 0, 0.5,-0.0044681)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00879337) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00756781) , 
0, 110.95, 1, 0, 0.0623323,-0.429208) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00454035) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00215032) , 
1, 131.149, 1, 0, 0.316101,-0.180424) , 
0, 115.908, 1, 0, 0.119467,-0.373195) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0227886) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00185536) , 
0, 128.919, 1, 0, 0.839532,0.316936) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00846804) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00837701) , 
0, 133.553, 1, 0, 0.0445632,-0.446925) , 
0, 130.907, 1, 0, 0.682913,0.166445) , 
0, 119.999, 1, 0, 0.5,-0.00873984)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00871113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00749692) , 
0, 110.95, 1, 0, 0.0623323,-0.42504) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00449575) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00211289) , 
1, 131.149, 1, 0, 0.316101,-0.17871) , 
0, 115.908, 1, 0, 0.119467,-0.36958) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0220826) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00183116) , 
0, 128.919, 1, 0, 0.839532,0.306214) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00834656) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00830613) , 
0, 133.553, 1, 0, 0.0445632,-0.442732) , 
0, 130.907, 1, 0, 0.682913,0.158662) , 
0, 119.999, 1, 0, 0.5,-0.0128228)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00826359) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00617448) , 
0, 112.809, 1, 0, 0.0735297,-0.410454) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308447,-0.00514956) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604148,0.00442817) , 
1, 131.149, 1, 0, 0.36086,-0.132401) , 
0, 117.272, 1, 0, 0.119467,-0.365999) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0214181) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00180729) , 
0, 128.919, 1, 0, 0.839532,0.295858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00822795) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00823696) , 
0, 133.553, 1, 0, 0.0445632,-0.438579) , 
0, 130.907, 1, 0, 0.682913,0.151164) , 
0, 119.999, 1, 0, 0.5,-0.0167241)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00819049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00612166) , 
0, 112.809, 1, 0, 0.0735297,-0.406621) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308447,-0.005078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604148,0.00433037) , 
1, 131.149, 1, 0, 0.36086,-0.130676) , 
0, 117.272, 1, 0, 0.119467,-0.362504) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0207908) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00178375) , 
0, 128.919, 1, 0, 0.839532,0.285855) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00811207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00816946) , 
0, 133.553, 1, 0, 0.0445632,-0.434467) , 
0, 130.907, 1, 0, 0.682913,0.143942) , 
0, 119.999, 1, 0, 0.5,-0.0204669)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00848292) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00730046) , 
0, 110.95, 1, 0, 0.0623323,-0.413158) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00434649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00201283) , 
1, 131.149, 1, 0, 0.316101,-0.172796) , 
0, 115.908, 1, 0, 0.119467,-0.359042) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0210945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,0.000833063) , 
0, 127.928, 1, 0, 0.839532,0.276192) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00799882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00810355) , 
0, 133.553, 1, 0, 0.0445632,-0.430396) , 
0, 130.907, 1, 0, 0.682913,0.136985) , 
0, 119.999, 1, 0, 0.5,-0.0240415)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00804814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00601732) , 
0, 112.809, 1, 0, 0.0735297,-0.398991) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.0042836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0179844) , 
11, 166.893, 1, 0, 0.36086,-0.127364) , 
0, 117.272, 1, 0, 0.119467,-0.355564) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0196317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00177137) , 
0, 128.919, 1, 0, 0.839532,0.26679) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0078881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00803919) , 
0, 133.553, 1, 0, 0.0445632,-0.426364) , 
0, 130.907, 1, 0, 0.682913,0.13023) , 
0, 119.999, 1, 0, 0.5,-0.0274748)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00797997) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.0059671) , 
0, 112.809, 1, 0, 0.0735297,-0.395266) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00684269) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000870999) , 
11, 42.4109, 1, 0, 0.36086,-0.125435) , 
0, 117.272, 1, 0, 0.119467,-0.352126) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0199549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,0.000695139) , 
0, 127.928, 1, 0, 0.839532,0.257774) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00777978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00797632) , 
0, 133.553, 1, 0, 0.0445632,-0.422371) , 
0, 130.907, 1, 0, 0.682913,0.123777) , 
0, 119.999, 1, 0, 0.5,-0.0307169)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00791332) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.0059177) , 
0, 112.809, 1, 0, 0.0735297,-0.391576) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308447,-0.00483404) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604148,0.00428456) , 
1, 131.149, 1, 0, 0.36086,-0.123592) , 
0, 117.272, 1, 0, 0.119467,-0.348731) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0185828) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00175735) , 
0, 128.919, 1, 0, 0.839532,0.249) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0076738) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00791489) , 
0, 133.553, 1, 0, 0.0445632,-0.418417) , 
0, 130.907, 1, 0, 0.682913,0.11751) , 
0, 119.999, 1, 0, 0.5,-0.033847)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00784814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00586909) , 
0, 112.809, 1, 0, 0.0735297,-0.387921) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00411576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0176907) , 
11, 166.893, 1, 0, 0.36086,-0.121986) , 
0, 117.272, 1, 0, 0.119467,-0.345404) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0189213) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,0.000567356) , 
0, 127.928, 1, 0, 0.839532,0.240587) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00757004) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00785486) , 
0, 133.553, 1, 0, 0.0445632,-0.414502) , 
0, 130.907, 1, 0, 0.682913,0.111526) , 
0, 119.999, 1, 0, 0.5,-0.0368084)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00778438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00582125) , 
0, 112.809, 1, 0, 0.0735297,-0.3843) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.0066318) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000768583) , 
11, 42.4109, 1, 0, 0.36086,-0.120138) , 
0, 117.272, 1, 0, 0.119467,-0.342067) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0176249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00174186) , 
0, 128.919, 1, 0, 0.839532,0.232398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00746842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00779617) , 
0, 133.553, 1, 0, 0.0445632,-0.410624) , 
0, 130.907, 1, 0, 0.682913,0.105714) , 
0, 119.999, 1, 0, 0.5,-0.03965)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00772199) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00577416) , 
0, 112.809, 1, 0, 0.0735297,-0.380713) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00626253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-0.0006866) , 
1, 66.1972, 1, 0, 0.36086,-0.118374) , 
0, 117.272, 1, 0, 0.119467,-0.338771) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0179756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,0.000448817) , 
0, 127.928, 1, 0, 0.839532,0.224547) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00736887) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00773878) , 
0, 133.553, 1, 0, 0.0445632,-0.406785) , 
0, 130.907, 1, 0, 0.682913,0.100166) , 
0, 119.999, 1, 0, 0.5,-0.0423274)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00766092) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.0057278) , 
0, 112.809, 1, 0, 0.0735297,-0.37716) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00395191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0174655) , 
11, 166.893, 1, 0, 0.36086,-0.116682) , 
0, 117.272, 1, 0, 0.119467,-0.335516) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0166784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,0.00193469) , 
3, 2.13998, 1, 0, 0.839532,0.216903) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0072713) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00768265) , 
0, 133.553, 1, 0, 0.0445632,-0.402982) , 
0, 130.907, 1, 0, 0.682913,0.0947771) , 
0, 119.999, 1, 0, 0.5,-0.04491)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00760113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00568214) , 
0, 112.809, 1, 0, 0.0735297,-0.37364) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00642859) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000664727) , 
11, 42.4109, 1, 0, 0.36086,-0.114914) , 
0, 117.272, 1, 0, 0.119467,-0.332276) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0163685) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00189951) , 
0, 128.919, 1, 0, 0.839532,0.209983) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00717564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00762773) , 
0, 133.553, 1, 0, 0.0445632,-0.399217) , 
0, 130.907, 1, 0, 0.682913,0.0899626) , 
0, 119.999, 1, 0, 0.5,-0.0471098)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.0078916) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00678195) , 
0, 110.95, 1, 0, 0.0623323,-0.379845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00395654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00228953) , 
1, 131.149, 1, 0, 0.316101,-0.154356) , 
0, 115.908, 1, 0, 0.119467,-0.329077) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.015901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,0.00154961) , 
3, 2.13998, 1, 0, 0.839532,0.202883) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00708183) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.007574) , 
0, 133.553, 1, 0, 0.0445632,-0.395488) , 
0, 130.907, 1, 0, 0.682913,0.0849956) , 
0, 119.999, 1, 0, 0.5,-0.0494259)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00748416) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00559187) , 
0, 112.809, 1, 0, 0.0735297,-0.366635) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00380129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0172169) , 
11, 166.893, 1, 0, 0.36086,-0.11181) , 
0, 117.272, 1, 0, 0.119467,-0.325894) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0163905) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-9.98366e-05) , 
0, 127.928, 1, 0, 0.839532,0.196416) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00698979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.0075214) , 
0, 133.553, 1, 0, 0.0445632,-0.391795) , 
0, 130.907, 1, 0, 0.682913,0.0805307) , 
0, 119.999, 1, 0, 0.5,-0.0514081)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00742797) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00554821) , 
0, 112.809, 1, 0, 0.0735297,-0.363214) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00596881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-0.000503632) , 
1, 66.1972, 1, 0, 0.36086,-0.110115) , 
0, 117.272, 1, 0, 0.119467,-0.322749) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0151722) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,0.00118407) , 
3, 2.13998, 1, 0, 0.839532,0.189713) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00689946) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00746991) , 
0, 133.553, 1, 0, 0.0445632,-0.388138) , 
0, 130.907, 1, 0, 0.682913,0.0758681) , 
0, 119.999, 1, 0, 0.5,-0.0535361)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.0073729) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00550519) , 
0, 112.809, 1, 0, 0.0735297,-0.359825) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.0061895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000532586) , 
11, 42.4109, 1, 0, 0.36086,-0.108546) , 
0, 117.272, 1, 0, 0.119467,-0.319651) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0149133) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00219808) , 
0, 128.919, 1, 0, 0.839532,0.183672) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00681079) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.0074195) , 
0, 133.553, 1, 0, 0.0445632,-0.384517) , 
0, 130.907, 1, 0, 0.682913,0.071731) , 
0, 119.999, 1, 0, 0.5,-0.0553245)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00731891) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00546279) , 
0, 112.809, 1, 0, 0.0735297,-0.356468) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00365219) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0170063) , 
11, 166.893, 1, 0, 0.36086,-0.106955) , 
0, 117.272, 1, 0, 0.119467,-0.316577) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.014493) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,0.000844881) , 
3, 2.13998, 1, 0, 0.839532,0.177448) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00672372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00737012) , 
0, 133.553, 1, 0, 0.0445632,-0.38093) , 
0, 130.907, 1, 0, 0.682913,0.06744) , 
0, 119.999, 1, 0, 0.5,-0.0572244)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00726597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00542099) , 
0, 112.809, 1, 0, 0.0735297,-0.353143) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308447,-0.00425317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604148,0.00445604) , 
1, 131.149, 1, 0, 0.36086,-0.105333) , 
0, 117.272, 1, 0, 0.119467,-0.313524) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0150049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-0.000583464) , 
0, 127.928, 1, 0, 0.839532,0.171803) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00663819) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00732175) , 
0, 133.553, 1, 0, 0.0445632,-0.377378) , 
0, 130.907, 1, 0, 0.682913,0.0636066) , 
0, 119.999, 1, 0, 0.5,-0.0588222)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.0075853) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00562879) , 
0, 110.578, 1, 0, 0.0735297,-0.349849) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00600907) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000449301) , 
11, 42.4109, 1, 0, 0.36086,-0.103991) , 
0, 117.272, 1, 0, 0.119467,-0.310542) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0139148) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00231274) , 
0, 128.919, 1, 0, 0.839532,0.16592) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00655415) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00727435) , 
0, 133.553, 1, 0, 0.0445632,-0.373861) , 
0, 130.907, 1, 0, 0.682913,0.0595761) , 
0, 119.999, 1, 0, 0.5,-0.0605762)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00750114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.00643485) , 
0, 110.95, 1, 0, 0.0623323,-0.355791) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00368622) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00243202) , 
1, 131.149, 1, 0, 0.316101,-0.141511) , 
0, 115.908, 1, 0, 0.119467,-0.307547) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0135559) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,0.00022986) , 
3, 2.13998, 1, 0, 0.839532,0.16029) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00647156) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.0072279) , 
0, 133.553, 1, 0, 0.0445632,-0.370377) , 
0, 130.907, 1, 0, 0.682913,0.0557414) , 
0, 119.999, 1, 0, 0.5,-0.0621937)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00711253) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00529631) , 
0, 112.809, 1, 0, 0.0735297,-0.343281) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00563919) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-0.000324424) , 
1, 66.1972, 1, 0, 0.36086,-0.10118) , 
0, 117.272, 1, 0, 0.119467,-0.304575) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0133075) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.0024227) , 
0, 128.919, 1, 0, 0.839532,0.155195) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00639036) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00718236) , 
0, 133.553, 1, 0, 0.0445632,-0.366928) , 
0, 130.907, 1, 0, 0.682913,0.0523299) , 
0, 119.999, 1, 0, 0.5,-0.063533)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00742811) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.0055034) , 
0, 110.578, 1, 0, 0.0735297,-0.34008) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00343307) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0167309) , 
11, 166.893, 1, 0, 0.36086,-0.0997428) , 
0, 117.272, 1, 0, 0.119467,-0.301655) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686035,-0.000666242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858123,0.0131187) , 
0, 121.981, 1, 0, 0.839532,0.149922) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00631052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00713772) , 
0, 133.553, 1, 0, 0.0445632,-0.363511) , 
0, 130.907, 1, 0, 0.682913,0.0487685) , 
0, 119.999, 1, 0, 0.5,-0.0649905)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00701568) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00521593) , 
0, 112.809, 1, 0, 0.0735297,-0.336897) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00579311) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000332955) , 
11, 42.4109, 1, 0, 0.36086,-0.0982294) , 
0, 117.272, 1, 0, 0.119467,-0.298739) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.013455) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-0.00111691) , 
0, 127.928, 1, 0, 0.839532,0.145001) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00623198) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00709395) , 
0, 133.553, 1, 0, 0.0445632,-0.360127) , 
0, 130.907, 1, 0, 0.682913,0.0454843) , 
0, 119.999, 1, 0, 0.5,-0.0662619)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00696836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00517746) , 
0, 112.809, 1, 0, 0.0735297,-0.333755) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00547608) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-0.000239382) , 
1, 66.1972, 1, 0, 0.36086,-0.096792) , 
0, 117.272, 1, 0, 0.119467,-0.29587) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0124259) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,-0.000608047) , 
3, 2.13998, 1, 0, 0.839532,0.140015) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00615472) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00705101) , 
0, 133.553, 1, 0, 0.0445632,-0.356776) , 
0, 130.907, 1, 0, 0.682913,0.04214) , 
0, 119.999, 1, 0, 0.5,-0.067589)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0398818,-0.00725201) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.100536,-0.0062097) , 
0, 110.95, 1, 0, 0.0623323,-0.339513) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.209985,-0.00403636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.416788,-0.00119705) , 
11, 42.4109, 1, 0, 0.316101,-0.133079) , 
0, 115.908, 1, 0, 0.119467,-0.293036) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686035,-0.00113873) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858123,0.0122681) , 
0, 121.981, 1, 0, 0.839532,0.135569) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00607868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00700889) , 
0, 133.553, 1, 0, 0.0445632,-0.353458) , 
0, 130.907, 1, 0, 0.682913,0.0392244) , 
0, 119.999, 1, 0, 0.5,-0.068638)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00723365) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00534325) , 
0, 110.578, 1, 0, 0.0735297,-0.327503) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00326394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0165473) , 
11, 166.893, 1, 0, 0.36086,-0.0941669) , 
0, 117.272, 1, 0, 0.119467,-0.290198) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0126321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-0.0014653) , 
0, 127.928, 1, 0, 0.839532,0.131121) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00600385) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00696757) , 
0, 133.553, 1, 0, 0.0445632,-0.350171) , 
0, 130.907, 1, 0, 0.682913,0.0363001) , 
0, 119.999, 1, 0, 0.5,-0.0696917)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00683085) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00506245) , 
0, 112.809, 1, 0, 0.0735297,-0.324438) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00532721) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-0.000159111) , 
1, 66.1972, 1, 0, 0.36086,-0.0927373) , 
0, 117.272, 1, 0, 0.119467,-0.287394) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0116438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,-0.00111156) , 
3, 2.13998, 1, 0, 0.839532,0.126597) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00593017) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00692701) , 
0, 133.553, 1, 0, 0.0445632,-0.346916) , 
0, 130.907, 1, 0, 0.682913,0.0333084) , 
0, 119.999, 1, 0, 0.5,-0.0708021)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00714157) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00526726) , 
0, 110.578, 1, 0, 0.0735297,-0.321413) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00317823) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0163521) , 
11, 166.893, 1, 0, 0.36086,-0.0914246) , 
0, 117.272, 1, 0, 0.119467,-0.284643) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.0113937) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.0029422) , 
0, 128.919, 1, 0, 0.839532,0.122582) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00585762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.0068872) , 
0, 133.553, 1, 0, 0.0445632,-0.343692) , 
0, 130.907, 1, 0, 0.682913,0.0307196) , 
0, 119.999, 1, 0, 0.5,-0.0716574)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00674377) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00498811) , 
0, 112.809, 1, 0, 0.0735297,-0.318405) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00548993) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-0.000165105) , 
11, 42.4109, 1, 0, 0.36086,-0.0900361) , 
0, 117.272, 1, 0, 0.119467,-0.281894) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686035,-0.00181758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858123,0.0112376) , 
0, 121.981, 1, 0, 0.839532,0.118392) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00578616) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00684813) , 
0, 133.553, 1, 0, 0.0445632,-0.340499) , 
0, 130.907, 1, 0, 0.682913,0.0279843) , 
0, 119.999, 1, 0, 0.5,-0.0726124)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0825538,-0.00591406) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0406051,-0.00750775) , 
3, 1.2088, 1, 0, 0.0623323,-0.323988) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.266695,-0.00335519) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563887,0.00271136) , 
1, 131.149, 1, 0, 0.316101,-0.125014) , 
0, 115.908, 1, 0, 0.119467,-0.27919) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0116065) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-0.0018332) , 
0, 127.928, 1, 0, 0.839532,0.114504) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00571577) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00680976) , 
0, 133.553, 1, 0, 0.0445632,-0.337337) , 
0, 130.907, 1, 0, 0.682913,0.0254853) , 
0, 119.999, 1, 0, 0.5,-0.0734223)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00701039) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00515317) , 
0, 110.578, 1, 0, 0.0735297,-0.312426) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.346099,-0.00306046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1.12666,0.0161422) , 
11, 166.893, 1, 0, 0.36086,-0.0876029) , 
0, 117.272, 1, 0, 0.119467,-0.276482) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.0106923) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,-0.00180717) , 
3, 2.13998, 1, 0, 0.839532,0.110533) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00564641) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00677207) , 
0, 133.553, 1, 0, 0.0445632,-0.334205) , 
0, 130.907, 1, 0, 0.682913,0.022914) , 
0, 119.999, 1, 0, 0.5,-0.0742796)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00661843) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00487617) , 
0, 112.809, 1, 0, 0.0735297,-0.309503) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.251438,-0.00509572) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.464216,-2.53466e-05) , 
1, 66.1972, 1, 0, 0.36086,-0.0862717) , 
0, 117.272, 1, 0, 0.119467,-0.273813) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.593474,-0.00534753) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.851169,0.0097115) , 
0, 120.99, 1, 0, 0.839532,0.10703) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00557806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00673506) , 
0, 133.553, 1, 0, 0.0445632,-0.331103) , 
0, 130.907, 1, 0, 0.682913,0.0207119) , 
0, 119.999, 1, 0, 0.5,-0.0749006)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00692599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00508202) , 
0, 110.578, 1, 0, 0.0735297,-0.306618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249212,-0.00530108) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460826,-6.90879e-05) , 
11, 42.4109, 1, 0, 0.36086,-0.0850546) , 
0, 117.272, 1, 0, 0.119467,-0.271195) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86191,0.010204) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427067,-0.00327137) , 
0, 128.919, 1, 0, 0.839532,0.103552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00551069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00669871) , 
0, 133.553, 1, 0, 0.0445632,-0.328031) , 
0, 130.907, 1, 0, 0.682913,0.0185245) , 
0, 119.999, 1, 0, 0.5,-0.0755279)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0825538,-0.00575647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0406051,-0.00733213) , 
3, 1.2088, 1, 0, 0.0623323,-0.312037) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.209985,-0.00376557) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.416788,-0.000915578) , 
11, 42.4109, 1, 0, 0.316101,-0.11905) , 
0, 115.908, 1, 0, 0.119467,-0.268587) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.857263,0.00943069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602798,-0.00482609) , 
4, 3.57541, 1, 0, 0.839532,0.0999932) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00544427) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00666298) , 
0, 133.553, 1, 0, 0.0445632,-0.324988) , 
0, 130.907, 1, 0, 0.682913,0.0162661) , 
0, 119.999, 1, 0, 0.5,-0.0762065)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0381175,-0.00684426) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118353,-0.00501011) , 
0, 110.578, 1, 0, 0.0735297,-0.30085) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36086,-0.00254243) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1,0.0119458) , 
1, 650.763, 1, 0, 0.36086,-0.0827069) , 
0, 117.272, 1, 0, 0.119467,-0.265974) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686035,-0.00268548) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.858123,0.00987293) , 
0, 121.981, 1, 0, 0.839532,0.0968321) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.00537878) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00662788) , 
0, 133.553, 1, 0, 0.0445632,-0.321975) , 
0, 130.907, 1, 0, 0.682913,0.0143214) , 
0, 119.999, 1, 0, 0.5,-0.0766717)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00646067) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.00473349) , 
0, 112.809, 1, 0, 0.0735297,-0.298036) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36086,-0.0025056) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1,0.0119447) , 
1, 650.763, 1, 0, 0.36086,-0.0814579) , 
0, 117.272, 1, 0, 0.119467,-0.26341) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869072,0.0102627) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.552342,-0.0024414) , 
0, 127.928, 1, 0, 0.839532,0.0936434) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0053142) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00659337) , 
0, 133.553, 1, 0, 0.0445632,-0.31899) , 
0, 130.907, 1, 0, 0.682913,0.012349) , 
0, 119.999, 1, 0, 0.5,-0.0771715)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0474091,-0.00642254) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.140252,-0.0047008) , 
0, 112.809, 1, 0, 0.0735297,-0.295259) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36086,-0.00246931) , 
NN(
0, 
0, 
-1, 0, 1, -99, 1,0.0119436) , 
1, 650.763, 1, 0, 0.36086,-0.0802278) , 
0, 117.272, 1, 0, 0.119467,-0.26088) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86571,0.00942515) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.654378,-0.00268086) , 
3, 2.13998, 1, 0, 0.839532,0.0903625) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.203546,-0.0052505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.016487,-0.00655945) , 
0, 133.553, 1, 0, 0.0445632,-0.316034) , 
0, 130.907, 1, 0, 0.682913,0.0102968) , 
0, 119.999, 1, 0, 0.5,-0.0777361)    );
   return;
};
 
// Clean up
inline void ReadBDTG_AWB_lite::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTG_AWB_lite::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
